---
layout: post
title:  "JVM内存结构"
categories: JAVA
tags:  JAVA JVM
author: 娄凯凯
---

* content
{:toc}

# JVM内存结构图解

![JVM内存结构图解](/image/jvm/JVM内存结构图解.png)



# 按照java运行的逻辑来讲解：
  1. 在JVM启动时会将java文件编译为class文件，class文件的字节码就保存在方法区，还有会把类的类型信息，域信息，方法信息保存在方法区。
   
  2. 当你开始new一个对象的时候，jvm就会开始类加载（java双亲委托的类加载机制），创建一个对象，内配内存空间（Heap）。

  3. 当你开始使用new user（）给对象分配内存空间就是分配在Heap上。Heap分为新生代，老年代，永久代（逻辑分区，1.8之后改为元数据）等。内存回收就是针对这一块。什么时候开始回收，什么时候会把新生代的对象放入老年代，都取决于垃圾回收算法

方法区区别区与堆，栈，如同下图：

![](https://www.notion.so/JVM-e8cfec37af31431f9acdbfc4a2b06850?pvs=4#b8ebcad24f0449aa9a58530b7187b41e)


![本地存储](/image/jvm/jvm.png)

# 方法区内部结构
  “尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩”。             ——————《Java虚拟机规范》

  但对于 HotSpot 虚拟机而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。
  方法区中主要存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等：

- ## 类信息
    
    对每个加载的类（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类信息：

    1.类的全限定名（完整包路径+类名
    
    2.类的父类的全限定名*
    
- ## 域信息
    
    类的作用域
    
- ## 方法信息
    1. 方法的作用域
    2. 方法的输入输出
    3. 方法的返回
    4. 方法的传参
    
- ## 变量（运行时常量）
   1. 方法的引用，类的常亮，类的符号引用，字符串常量

# Heap （堆）

堆是线程共享的，因为所有的类的实例都在这里，不可能私有

- ## 组成
    
    - 堆内存逻辑上由新生代 ( Young )、老年代 ( Old )、永久代(Perm)组成。
    
    - 新生代 ( Young )包括：Eden、From Survivor(From幸存区)和To Survivor(To幸存区)组成。
    
- ## 堆内存内部空间所占比例
    
    - 新生代与老年代的默认比例： 1:2。
    
    - 新生代区的默认比例是：8:1:1。
    
    说明：在 HotSpot 中，Eden 空间和另外两个 SurvIvor 空间缺省所占的比例是 8:1:1。
    
- ## 永久代和元空间区别
    
    - 永久代：使用的是JVM的内存;存储字符串和数组容易出现性能和内存溢出问题，大小不好指定，GC复杂度高。
    
    - 元空间：不再使用JVM的内存而是使用计算机本地内存，元空间大小只受本地内存限制。
    
    元空间的设置参数：-XX:MetaspaceSize(初始值值)和-XX:MaxMetaspaceSize(最大值)。
    

- ## 堆空间的大小设置
    - Xms：表示堆区的初始内存，等价于 -XX:InitialHeapSize。
    - Xmx ：表示堆区的最大内存，等价于 -XX:MaxHeapSize。
    
    注意：如果堆中的内存大小超过 “-Xmx" 所指定的最大内存值的时候，将会抛出 OutOfMemoryError 异常。
    
    说明：一般情况下会将 -Xms 和 -Xmx 两个参数配置相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后避免重新分隔计算堆区的大小，从而提高性能。
    
    默认情况下：
    
    - 初始内存：物理电脑内存大小 / 64。
    - 最大内存：物理电脑内存大小 / 4。

- ## 堆空间垃圾回收
    
    堆空间的垃圾回收有三种机制，MinorGC，MajorGC，FullGC。
    
    - Minor GC：清理年轻代内存空间(包括 Eden 和 Survivor 区域)，释放在Eden中所有不活跃的对象，释放后若Eden空间还不满足以放入新对象，JVM会试图将部分Eden中活跃对象放入Survivor区。Survivor区被用来作为Eden及老年代的中间交换区域，如果老年代空间满了，Survivor区的对象会被移到老年代，否则会被保留在Survivor区。
    
    - Major GC：清理老年代内存空间，当老年代空间不够时，JVM会在老年代进行Major GC。
    
    - Full GC：清理JVM整个堆内存空间，包括年轻代和老年代空间。

# stack

    栈是线程私有的，，需要运行（执行）实例方法的时候都会创建一个栈帧，栈帧包含局部变量表、操作数栈、动态连接、方法出口等。栈是一个大的数据结构，包含了很多被压入等待执行的栈桢

    ![本地存储](/image/jvm/stack.png)

 ## Java虚拟机栈

  1. Java虚拟机栈也是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）

  2. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
   如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；
   （当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈）

  3. Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧。

对于我们来说，主要关注的stack栈内存，就是虚拟机栈中局部变量表部分。

```
在编译程序代码的时候，栈帧中需要多大的局部变量表内存，多深的操作数栈都已经完全确定了。

因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
```

## 栈桢

运行（执行）实例方法的时候都会创建一个**栈帧**，栈帧包含局部变量表、操作数栈、动态连接、方法出口等

  1. 局部变量表
    
        变量槽
    
  2. 操作数栈
    
   操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即PUSH和POP。某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用后把结果压入栈比如：执行复制，交换，求和等操作*
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316153344001-849992078.png)
    
    **操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。**
    
    操作数栈就是JVM执行引擎的有一个工作区，当一个方法刚开始执行的时候，
    一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。
    
    每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，
    保存在方法的Code属性中，为max_stack的值。栈中任何一个元素都可以是任意Java数据类型
    
    32bit占一个栈单位深度
    
    64bit占一个栈单位深度
    
    操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的PUSH和POP操作来完成一次数据访问
    
    如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈当中，并更新PC寄存器中下一条需要执行的字节码指令
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316174332878-1218274088.png)
    
    一上来就aload_0，调用有返回值的方法
    
    操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器期间进行验证，同时在类加载
    
    # **代码追踪**
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316170147126-613805333.png)
    
    使用javap命令反编译class文件：javap - v 类名.class
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316170559188-1078031978.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316170808006-190674233.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316170832804-1345926801.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316170909597-1429689572.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316170937976-1610023640.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316171037673-1238776502.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316171053625-1954735032.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316172011975-1612720296.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316172059831-441892689.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316172414359-1767263702.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316172430680-33866770.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316172622039-894909301.png)
    
    ![](https://img2020.cnblogs.com/i-beta/1548492/202003/1548492-20200316172628884-352483143.png)
    
    一个字节就能存，所以bipush ；800的话就是sipush；
    
    还有一点：byte、short、char、boolen都是以int来保存。
    
    栈顶缓存技术（Top-of-Stack-Cashing）
    
    前面提过，基于栈式架构的虚拟机所使用的零地址地址更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着需要将更多的指令分派次数和内存读写次数
    
    由于操作数是存储在内存中的，因此频繁的执行读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM设计者提出栈顶缓存技术，**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。**
    
- 3.动态连接
    
    动态链接是在程序运行期间完成的将符号引用替换为直接引用，
    
- 4.方法出口
    当一个方法开始执行后，只有2种方式可以退出这个方法 ：

    - 方法返回指令 ： 执行引擎遇到一个方法返回的字节码指令，这时候有可能会有返回值传递给上层的方法调用者，这种退出方式称为正常完成出口。
  
    - 异常退出 ： 在方法执行过程中遇到了异常，并且没有处理这个异常，就会导致方法退出。
      无论采用任何退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息。*

     一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中会保存这个计数器值。
     而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。*